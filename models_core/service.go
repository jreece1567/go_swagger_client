package models_core

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

/*Service service

swagger:model service
*/
type Service struct {

	/* links

	Required: true
	*/
	Links *ServiceLinks `json:"_links"`

	/* Whether the service is currently available

	Required: true
	*/
	Active *bool `json:"active"`

	/* Centre in which the service is available

	Required: true
	*/
	CentreID *string `json:"centre_id"`

	/* Date and time the centre service was marked as deleted
	 */
	DeletedAt strfmt.DateTime `json:"deleted_at,omitempty"`

	/* Full description

	Required: true
	*/
	Description *string `json:"description"`

	/* Email for Service

	Required: true
	*/
	Email *string `json:"email"`

	/* List of available opening hours

	Required: true
	*/
	Hours []*ServiceHourBody `json:"hours"`

	/* List of available locations

	Required: true
	*/
	Locations []*ServiceLocationBody `json:"locations"`

	/* Long title

	Required: true
	*/
	LongTitle *string `json:"long_title"`

	/* Phone number for the Service

	Required: true
	*/
	PhoneNumber *string `json:"phone_number"`

	/* List of available rates

	Required: true
	*/
	Rates []*ServiceRateBody `json:"rates"`

	/* Class of the service type

	Required: true
	*/
	ServiceClass *string `json:"service_class"`

	/* Service identifier

	Required: true
	*/
	ServiceID *int64 `json:"service_id"`

	/* Type of service

	Required: true
	*/
	ServiceType *string `json:"service_type"`

	/* Short title

	Required: true
	*/
	ShortTitle *string `json:"short_title"`

	/* Expected order of appearance in lists

	Required: true
	*/
	SortOrder *int64 `json:"sort_order"`

	/* Date and time the centre service was last updated.

	Required: true
	*/
	UpdatedAt *strfmt.DateTime `json:"updated_at"`

	/* External URL

	Required: true
	*/
	URL *string `json:"url"`
}

// Validate validates this service
func (m *Service) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateActive(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCentreID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEmail(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateHours(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLocations(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLongTitle(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePhoneNumber(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRates(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateServiceClass(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateServiceID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateServiceType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateShortTitle(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSortOrder(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Service) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("_links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {

		if err := m.Links.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *Service) validateActive(formats strfmt.Registry) error {

	if err := validate.Required("active", "body", m.Active); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateCentreID(formats strfmt.Registry) error {

	if err := validate.Required("centre_id", "body", m.CentreID); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateEmail(formats strfmt.Registry) error {

	if err := validate.Required("email", "body", m.Email); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateHours(formats strfmt.Registry) error {

	if err := validate.Required("hours", "body", m.Hours); err != nil {
		return err
	}

	for i := 0; i < len(m.Hours); i++ {

		if swag.IsZero(m.Hours[i]) { // not required
			continue
		}

		if m.Hours[i] != nil {

			if err := m.Hours[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *Service) validateLocations(formats strfmt.Registry) error {

	if err := validate.Required("locations", "body", m.Locations); err != nil {
		return err
	}

	for i := 0; i < len(m.Locations); i++ {

		if swag.IsZero(m.Locations[i]) { // not required
			continue
		}

		if m.Locations[i] != nil {

			if err := m.Locations[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *Service) validateLongTitle(formats strfmt.Registry) error {

	if err := validate.Required("long_title", "body", m.LongTitle); err != nil {
		return err
	}

	return nil
}

func (m *Service) validatePhoneNumber(formats strfmt.Registry) error {

	if err := validate.Required("phone_number", "body", m.PhoneNumber); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateRates(formats strfmt.Registry) error {

	if err := validate.Required("rates", "body", m.Rates); err != nil {
		return err
	}

	for i := 0; i < len(m.Rates); i++ {

		if swag.IsZero(m.Rates[i]) { // not required
			continue
		}

		if m.Rates[i] != nil {

			if err := m.Rates[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

var serviceTypeServiceClassPropEnum []interface{}

// prop value enum
func (m *Service) validateServiceClassEnum(path, location string, value string) error {
	if serviceTypeServiceClassPropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["physical","digital"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			serviceTypeServiceClassPropEnum = append(serviceTypeServiceClassPropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, serviceTypeServiceClassPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Service) validateServiceClass(formats strfmt.Registry) error {

	if err := validate.Required("service_class", "body", m.ServiceClass); err != nil {
		return err
	}

	// value enum
	if err := m.validateServiceClassEnum("service_class", "body", *m.ServiceClass); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateServiceID(formats strfmt.Registry) error {

	if err := validate.Required("service_id", "body", m.ServiceID); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateServiceType(formats strfmt.Registry) error {

	if err := validate.Required("service_type", "body", m.ServiceType); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateShortTitle(formats strfmt.Registry) error {

	if err := validate.Required("short_title", "body", m.ShortTitle); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateSortOrder(formats strfmt.Registry) error {

	if err := validate.Required("sort_order", "body", m.SortOrder); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateUpdatedAt(formats strfmt.Registry) error {

	if err := validate.Required("updated_at", "body", m.UpdatedAt); err != nil {
		return err
	}

	return nil
}

func (m *Service) validateURL(formats strfmt.Registry) error {

	if err := validate.Required("url", "body", m.URL); err != nil {
		return err
	}

	return nil
}
