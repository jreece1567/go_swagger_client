package models_core

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

/*EventInstance event instance

swagger:model eventInstance
*/
type EventInstance struct {

	/* embedded

	Required: true
	*/
	Embedded *EventEmbedded `json:"_embedded"`

	/* links

	Required: true
	*/
	Links *EventLinks `json:"_links"`

	/* Identifiers of categories the event belongs to

	Required: true
	*/
	CategoryIds []int64 `json:"category_ids"`

	/* Identifier of the centre the event belongs to

	Required: true
	*/
	CentreID *string `json:"centre_id"`

	/* Date and time that the event was marked as deleted.
	 */
	DeletedAt strfmt.DateTime `json:"deleted_at,omitempty"`

	/* Event description

	Required: true
	*/
	Description *string `json:"description"`

	/* Ending date and time of the last occurrence

	Required: true
	*/
	DisabledAt *strfmt.DateTime `json:"disabled_at"`

	/* Starting date and time of the first occurrence

	Required: true
	*/
	EnabledAt *strfmt.DateTime `json:"enabled_at"`

	/* Event identifier

	Required: true
	*/
	EventID *int64 `json:"event_id"`

	/* External URL to buy tickets to event

	Required: true
	*/
	ExternalBuyURL *string `json:"external_buy_url"`

	/* External URL for event information

	Required: true
	*/
	ExternalURL *string `json:"external_url"`

	/* External URL information description

	Required: true
	*/
	ExternalURLDescription *string `json:"external_url_description"`

	/* Featured

	Required: true
	*/
	Featured *bool `json:"featured"`

	/* List of jibestream locations and meta data

	Required: true
	*/
	Locations []*Location `json:"locations"`

	/* Event name

	Required: true
	*/
	Name *string `json:"name"`

	/* One or more occurrences of event

	Required: true
	*/
	Occurrences []*Occurrence `json:"occurrences"`

	/* The date-time the event was published

	Required: true
	*/
	PublishedAt *strfmt.DateTime `json:"published_at"`

	/* Retailers and stores associated with the event

	Required: true
	*/
	Retailers []*EventRetailer `json:"retailers"`

	/* The IANA timezone code for the event.

	Required: true
	*/
	TimeZone *string `json:"time_zone"`

	/* Date the event was last updated

	Required: true
	*/
	UpdatedAt *strfmt.DateTime `json:"updated_at"`
}

// Validate validates this event instance
func (m *EventInstance) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEmbedded(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCategoryIds(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCentreID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDisabledAt(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEnabledAt(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEventID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateExternalBuyURL(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateExternalURL(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateExternalURLDescription(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFeatured(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLocations(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateOccurrences(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePublishedAt(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRetailers(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTimeZone(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EventInstance) validateEmbedded(formats strfmt.Registry) error {

	if err := validate.Required("_embedded", "body", m.Embedded); err != nil {
		return err
	}

	if m.Embedded != nil {

		if err := m.Embedded.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *EventInstance) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("_links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {

		if err := m.Links.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *EventInstance) validateCategoryIds(formats strfmt.Registry) error {

	if err := validate.Required("category_ids", "body", m.CategoryIds); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateCentreID(formats strfmt.Registry) error {

	if err := validate.Required("centre_id", "body", m.CentreID); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateDisabledAt(formats strfmt.Registry) error {

	if err := validate.Required("disabled_at", "body", m.DisabledAt); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateEnabledAt(formats strfmt.Registry) error {

	if err := validate.Required("enabled_at", "body", m.EnabledAt); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateEventID(formats strfmt.Registry) error {

	if err := validate.Required("event_id", "body", m.EventID); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateExternalBuyURL(formats strfmt.Registry) error {

	if err := validate.Required("external_buy_url", "body", m.ExternalBuyURL); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateExternalURL(formats strfmt.Registry) error {

	if err := validate.Required("external_url", "body", m.ExternalURL); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateExternalURLDescription(formats strfmt.Registry) error {

	if err := validate.Required("external_url_description", "body", m.ExternalURLDescription); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateFeatured(formats strfmt.Registry) error {

	if err := validate.Required("featured", "body", m.Featured); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateLocations(formats strfmt.Registry) error {

	if err := validate.Required("locations", "body", m.Locations); err != nil {
		return err
	}

	for i := 0; i < len(m.Locations); i++ {

		if swag.IsZero(m.Locations[i]) { // not required
			continue
		}

		if m.Locations[i] != nil {

			if err := m.Locations[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *EventInstance) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateOccurrences(formats strfmt.Registry) error {

	if err := validate.Required("occurrences", "body", m.Occurrences); err != nil {
		return err
	}

	for i := 0; i < len(m.Occurrences); i++ {

		if swag.IsZero(m.Occurrences[i]) { // not required
			continue
		}

		if m.Occurrences[i] != nil {

			if err := m.Occurrences[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *EventInstance) validatePublishedAt(formats strfmt.Registry) error {

	if err := validate.Required("published_at", "body", m.PublishedAt); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateRetailers(formats strfmt.Registry) error {

	if err := validate.Required("retailers", "body", m.Retailers); err != nil {
		return err
	}

	for i := 0; i < len(m.Retailers); i++ {

		if swag.IsZero(m.Retailers[i]) { // not required
			continue
		}

		if m.Retailers[i] != nil {

			if err := m.Retailers[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *EventInstance) validateTimeZone(formats strfmt.Registry) error {

	if err := validate.Required("time_zone", "body", m.TimeZone); err != nil {
		return err
	}

	return nil
}

func (m *EventInstance) validateUpdatedAt(formats strfmt.Registry) error {

	if err := validate.Required("updated_at", "body", m.UpdatedAt); err != nil {
		return err
	}

	return nil
}
